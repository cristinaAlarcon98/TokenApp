{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\n/** Pattern mask */\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    super({\n      ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this.exposeBlock = undefined;\n    this._stops = [];\n    this._maskedBlocks = {};\n    const pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          const {\n            expose,\n            ...blockOpts\n          } = normalizeOpts(this.blocks[bName]);\n          const maskedBlock = createMask({\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            ...blockOpts,\n            parent: this\n          });\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n            if (expose) this.exposeBlock = maskedBlock;\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n  get state() {\n    return {\n      ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n  set state(state) {\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n  get isComplete() {\n    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\n  }\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n  get unmaskedValue() {\n    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.unmaskedValue = unmaskedValue;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get value() {\n    return this.exposeBlock ? this.exposeBlock.value :\n    // TODO return _value when not in change?\n    this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.value = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.value = value;\n  }\n  get typedValue() {\n    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\n  }\n  set typedValue(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.typedValue = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.typedValue = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const blockIter = this._mapPosToBlock(this.displayValue.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.displayValue.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n        const bDetails = b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.displayValue;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\n  }\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.displayValue.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["ChangeDetails","IMask","DIRECTION","Masked","createMask","normalizeOpts","ChunksTailDetails","PatternCursor","PatternFixedDefinition","PatternInputDefinition","MaskedPattern","constructor","opts","DEFAULTS","definitions","Object","assign","DEFAULT_DEFINITIONS","updateOptions","_update","_rebuildMask","defs","_blocks","exposeBlock","undefined","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","length","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","expose","blockOpts","maskedBlock","lazy","eager","placeholderChar","displayChar","overwrite","parent","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","state","map","maskedState","forEach","bi","reset","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","tail","extractTail","_blockStartPos","displayValue","appendTail","value","typedValue","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","blockIndex","extend","extractInput","input","_","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","_blocks2","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","totalInputPositions","total","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["/Users/cristinaalarcon/Desktop/TokenApp/frontend/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\n/** Pattern mask */\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    super({\n      ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this.exposeBlock = undefined;\n    this._stops = [];\n    this._maskedBlocks = {};\n    const pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          const {\n            expose,\n            ...blockOpts\n          } = normalizeOpts(this.blocks[bName]);\n          const maskedBlock = createMask({\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            ...blockOpts,\n            parent: this\n          });\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n            if (expose) this.exposeBlock = maskedBlock;\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n  get state() {\n    return {\n      ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n  set state(state) {\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n  get isComplete() {\n    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\n  }\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n  get unmaskedValue() {\n    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.unmaskedValue = unmaskedValue;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get value() {\n    return this.exposeBlock ? this.exposeBlock.value :\n    // TODO return _value when not in change?\n    this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.value = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.value = value;\n  }\n  get typedValue() {\n    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\n  }\n  set typedValue(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.typedValue = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.typedValue = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const blockIter = this._mapPosToBlock(this.displayValue.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.displayValue.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n        const bDetails = b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.displayValue;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\n  }\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.displayValue.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}